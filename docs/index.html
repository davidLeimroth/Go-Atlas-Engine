<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Atlas Engine: Atlas Engine</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Atlas Engine
   &#160;<span id="projectnumber">Detailed documentation</span>
   </div>
   <div id="projectbrief">A cross-platform engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="dd/db5/a00365.html">Atlas</a> Engine </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="image.png" alt="Example scene"/>
</div>
 <h2>Introduction</h2>
<p>This is a cross platform engine that is available on all major platforms including Linux, Windows, MacOS and Android. &gt;**Note:** &gt;MacOS only supports OpenGL up to version 4.1. Support is temporarily disabled until Vulkan is supported by the engine. &gt;Only 64 bit compilation is supported </p><h2>Requirements</h2>
<ul>
<li>OpenGL 4.3 or higher</li>
<li>OpenGL ES 3.2 <h2>Installation</h2>
</li>
</ul>
<p>Before you start compiling make sure to download the dependencies into **./dependencies**. You can either do this manually or use one of the available scripts. Building the engine is really convenient: You can use your source code and project across all supported platforms. The only thing that differs are the build tools. &gt;**Note:** &gt;Debugging the resulting application in a debug configuration will result in poor performance. </p><h3>Linux, Windows and MacOS</h3>
<p>The installation is done using CMake. There are two options available: Start a new project with a predefined main file which you can edit. The second option is two use the engine as a subproject in an already existing project. </p><h4>New project using the engine</h4>
<p>After running CMake you can find the main file at **./src/main.cpp**. Just start your project there, it already contains a main function. </p><h4>Excisting project using the engine</h4>
<p>There exist two options:</p><ul>
<li>You can use the engine as a CMake subproject. Just go ahead and use <b>add_subdirectory</b> in the root CMakeLists.txt of your project. Afterwards add <b>target_link_libraries(YOUR_TARGET ... AtlasEngine)</b>. You should be fine.</li>
<li>You can compile the engine and all dependencies as a static library (note that some dependencies also have dynamic libraries). Therefore use the <b>BUILD_LIBRARY</b> option when using CMake. <h3>Android</h3>
</li>
</ul>
<p>The installation for Android is done differently. You can compile it using Gradle either with or without AndroidStudio. The Gradle project can be found in **./platform/android**. Open it before you proceed. There are also two options available: Start a new project with a predefined main file which you can edit. The second option is two use the engine as a subproject in an already existing project. </p><h4>New project using the engine</h4>
<p>You can find the main file at **./src/main.cpp**. Just start your project there, it already contains a main function. </p><h4>Excisting project using the engine</h4>
<p>There exist two options:</p><ul>
<li>You can use the engine as a Gradle subproject.</li>
<li>You can compile the engine and all dependencies as a static library (note that some dependencies also have dynamic libraries). Therefore set the project property to <b>BUILD_LIBRARY</b>. <h2>Documentation</h2>
</li>
</ul>
<p>If you want more information have a look into the <a href="https://tippesi.github.io/Atlas-Engine/index.html">Documentation</a> </p><h2>General performance tips</h2>
<ul>
<li>Use static/stationary objects and lights as often as possible</li>
<li>Use textures with the same size and format for each material</li>
<li>Set mesh data or any kind of data prior to rendering. More importantly: Don't create data while rendering.</li>
<li>Try to avoid using OpenGL, use existing engine features instead</li>
<li>Reduce the number of samples used for anisotropic filtering (default is the maximum possbile number of samples) <h2>Code Example</h2>
</li>
</ul>
<p>Here is a small introduction to the engine </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="db/db2/a00020.html">Engine.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="d4/d81/a00110.html">input/Mouse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="df/d98/a00107.html">input/Keyboard.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div><div class="line"></div><div class="line">    <span class="comment">// After initializing the engine we will get back a window object.</span></div><div class="line">    <span class="comment">// We also need to tell in which directory all the assets are, so that</span></div><div class="line">    <span class="comment">// we can use relative paths later on. Note that everything about the</span></div><div class="line">    <span class="comment">// engine is in the Atlas namespace.</span></div><div class="line">    <span class="keyword">auto</span> window = <a class="code" href="d1/d8b/a00406.html#a0ef53160610d0af272802fc580626f00">Atlas::Engine::Init</a>(<span class="stringliteral">&quot;../data&quot;</span>, <span class="stringliteral">&quot;shader&quot;</span>, <span class="stringliteral">&quot;Example application&quot;</span>,</div><div class="line">            <a class="code" href="dc/dee/a00053.html#aad2ba7702aa02aa24dbf3e2b5f191554">AE_WINDOWPOSITION_UNDEFINED</a>, <a class="code" href="dc/dee/a00053.html#aad2ba7702aa02aa24dbf3e2b5f191554">AE_WINDOWPOSITION_UNDEFINED</a>, 1280, 720, <a class="code" href="dc/dee/a00053.html#aa2740f52b7899850bf3998b9adbeddd1">AE_WINDOW_RESIZABLE</a>);</div><div class="line"></div><div class="line">    <span class="comment">// Load an icon for the window</span></div><div class="line">    <span class="keyword">auto</span> icon = <a class="code" href="d5/d12/a00794.html">Atlas::Texture::Texture2D</a>(<span class="stringliteral">&quot;icon.png&quot;</span>);</div><div class="line">    window-&gt;SetIcon(&amp;icon);</div><div class="line">    window-&gt;Update();</div><div class="line"></div><div class="line">    <span class="comment">// Let&#39;s set up our render target. All things get drawn to the render target</span></div><div class="line">    <span class="comment">// before they are displayed.</span></div><div class="line">    <span class="keyword">auto</span> renderTarget = <a class="code" href="de/df4/a00450.html">Atlas::RenderTarget</a>(1920, 1080);</div><div class="line"></div><div class="line">    <span class="comment">// We also need a master renderer</span></div><div class="line">    <span class="keyword">auto</span> masterRenderer = <a class="code" href="d1/d97/a00670.html">Atlas::Renderer::MasterRenderer</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Now create our scene</span></div><div class="line">    <span class="keyword">auto</span> scene = <a class="code" href="d3/dd1/a00914.html">Atlas::Scene::Scene</a>();</div><div class="line"></div><div class="line">    <span class="comment">// We want to have a camera too</span></div><div class="line">    <span class="keyword">auto</span> camera = <a class="code" href="d9/d0a/a00390.html">Atlas::Camera</a>(47.0f, 2.0f, 1.0f, 400.0f, vec3(30.0f, 25.0f, 0.0f), vec2(-3.14f / 2.0f, 0.0f));</div><div class="line"></div><div class="line">    <span class="comment">// Now load the meshes we later want to use to create instances of them.</span></div><div class="line">    <span class="comment">// We can add these instances of meshes, called MeshActor to our scene.</span></div><div class="line">    <span class="keyword">auto</span> sponzaMesh = <a class="code" href="da/d6e/a00610.html">Atlas::Mesh::Mesh</a>(<span class="stringliteral">&quot;sponza/sponza.dae&quot;</span>, <a class="code" href="d3/df8/a00155.html#afe3d8327a0f9ccc13d6154618116ddad">AE_STATIONARY_MESH</a>);</div><div class="line">    <span class="keyword">auto</span> treeMesh = <a class="code" href="da/d6e/a00610.html">Atlas::Mesh::Mesh</a>(<span class="stringliteral">&quot;tree.dae&quot;</span>, <a class="code" href="d3/df8/a00155.html#afe3d8327a0f9ccc13d6154618116ddad">AE_STATIONARY_MESH</a>);</div><div class="line">    <span class="keyword">auto</span> cubeMesh = <a class="code" href="da/d6e/a00610.html">Atlas::Mesh::Mesh</a>(<span class="stringliteral">&quot;cube.dae&quot;</span>, <a class="code" href="d3/df8/a00155.html#adb7b4944b8d8b3bbb0cffe8f03f8cd6c">AE_MOVABLE_MESH</a>);</div><div class="line"></div><div class="line">    <span class="comment">// Notice that we want to move our cube later on. All meshes where we frequently want to</span></div><div class="line">    <span class="comment">// update the positions should be AE_MOVABLE_MESH. Let&#39;s create our MeshActors then:</span></div><div class="line">    <span class="keyword">auto</span> sponzaActor = <a class="code" href="da/dd8/a00906.html">Atlas::Actor::StaticMeshActor</a>(&amp;sponzaMesh, glm::scale(vec3(0.05f)));</div><div class="line">    <span class="keyword">auto</span> treeActor = <a class="code" href="da/dd8/a00906.html">Atlas::Actor::StaticMeshActor</a>(&amp;treeMesh, glm::scale(vec3(3.0f)));</div><div class="line">    <span class="keyword">auto</span> cubeActor = <a class="code" href="d5/dd3/a00902.html">Atlas::Actor::MovableMeshActor</a>(&amp;cubeMesh);</div><div class="line"></div><div class="line">    <span class="comment">// We create a scene node, which we can later move around.</span></div><div class="line">    <span class="comment">// The concept is really easy to understand: All actors of all the different types</span></div><div class="line">    <span class="comment">// which are added to that scene node translate, rotate and scale relative to the translation,</span></div><div class="line">    <span class="comment">// rotation and scale of that scene node.</span></div><div class="line">    <span class="keyword">auto</span> sceneNode = <a class="code" href="d0/ddf/a00918.html">Atlas::Scene::SceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Notice that we add the scene node. The root node can also be translated, rotated and scaled.</span></div><div class="line">    <span class="comment">// We will use this later on.</span></div><div class="line">    scene.Add(&amp;sceneNode);</div><div class="line"></div><div class="line">    <span class="comment">// Translate the scene node</span></div><div class="line">    sceneNode.SetMatrix(glm::translate(vec3(0.0f, 1.0f, 5.0f)));</div><div class="line"></div><div class="line">    <span class="comment">// We can also add the actors to scene without adding them to a scene node.</span></div><div class="line">    <span class="comment">// This means that all actors added this way have an absolute translation, rotation and scale.</span></div><div class="line">    scene.Add(&amp;sponzaActor);</div><div class="line">    scene.Add(&amp;treeActor);</div><div class="line"></div><div class="line">    sceneNode.Add(&amp;cubeActor);</div><div class="line"></div><div class="line">    <span class="comment">// Let&#39;s also create a global directional light. This is also stationary for this example scene.</span></div><div class="line">    <span class="keyword">auto</span> directionalLight = <a class="code" href="d4/dbe/a00574.html">Atlas::Lighting::DirectionalLight</a>(<a class="code" href="de/d76/a00134.html#a0c47343b7929f66f59ed14286415ece1">AE_STATIONARY_LIGHT</a>);</div><div class="line"></div><div class="line">    <span class="comment">// Now we can change this light to our needs</span></div><div class="line">    directionalLight.direction = vec3(0.0f, -1.0f, 0.1f);</div><div class="line">    directionalLight.ambient = 0.05f;</div><div class="line">    directionalLight.color = vec3(253.0f, 194.0f, 109.0f) / 255.0f;</div><div class="line"></div><div class="line">    <span class="comment">// Shadow mapping that is fixed to a point</span></div><div class="line">    mat4 orthoProjection = glm::ortho(-100.0f, 100.0f, -70.0f, 120.0f, -120.0f, 120.0f);</div><div class="line">    directionalLight.AddShadow(200.0f, 0.01f, 4096, vec3(0.0f), orthoProjection);</div><div class="line">    directionalLight.GetShadow()-&gt;sampleCount = 1;</div><div class="line"></div><div class="line">    <span class="comment">// A shadow has to be added to work</span></div><div class="line">    directionalLight.AddVolumetric(renderTarget.width / 2, renderTarget.height / 2, 20, -0.5f);</div><div class="line"></div><div class="line">    scene.Add(&amp;directionalLight);</div><div class="line"></div><div class="line">    <span class="comment">// We also want to interact with our little application. We therefore create a keyboard and mouse</span></div><div class="line">    <span class="comment">// handler. The handlers which are currently present in the engine are very basic but can be seen</span></div><div class="line">    <span class="comment">// as an example on how to write your own ones.</span></div><div class="line">    <span class="keyword">auto</span> mouseHandler = <a class="code" href="d0/ddb/a00542.html">Atlas::Input::MouseHandler</a>(&amp;camera, 1.5f, 0.015f);</div><div class="line">    <span class="keyword">auto</span> keyboardHandler = <a class="code" href="dd/d5a/a00538.html">Atlas::Input::KeyboardHandler</a>(&amp;camera, 7.0f, 0.3f);</div><div class="line"></div><div class="line">    <span class="comment">// We might also want to know when to exit the application. The engine has an event system build</span></div><div class="line">    <span class="comment">// in. We use it to catch the events from the user. In this case we want to know if the user has</span></div><div class="line">    <span class="comment">// closed the window (QuitEvent) or if the user pressed the escape button (KeyboardEvent).</span></div><div class="line">    <span class="keywordtype">bool</span> quit = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <a class="code" href="d8/d57/a00498.html#a2aaa97c45b181f99d52b3276a8838ad2">Atlas::Events::EventManager::QuitEventDelegate</a>.<a class="code" href="d5/d0f/a00494.html#a3b9ca815f00b2d7915e7ada41d8e0bf5">Subscribe</a>([&amp;quit]() {quit = <span class="keyword">true</span>;});</div><div class="line"></div><div class="line">    <a class="code" href="d8/d57/a00498.html#a3c3d9f544154e14a6afe35e8860890ff">Atlas::Events::EventManager::KeyboardEventDelegate</a>.Subscribe([&amp;quit](<a class="code" href="d4/d1f/a00506.html">Atlas::Events::KeyboardEvent</a> event) {</div><div class="line">        <span class="keywordflow">if</span> (event.<a class="code" href="d4/d1f/a00506.html#a012478caaa8c4b0d7537e8eac3589c43">keycode</a> == <a class="code" href="d2/d1f/a00083.html#a06fc87d81c62e9abb8790b6e5713c55bae0bb3f0e918fb30bc049159a43e79b38">AE_KEY_ESCAPE</a>) {</div><div class="line">            quit = true;</div><div class="line">        }</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="keywordtype">float</span> time = 0.0f;</div><div class="line"></div><div class="line">    <span class="comment">// We now have a main loop here which does all the rendering on a regular basis.</span></div><div class="line">    <span class="comment">// The framerate is locked as a standard but can also be unlocked via Atlas::Engine::UnlockFramerate()</span></div><div class="line">    <span class="keywordflow">while</span> (!quit) {</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> deltaTime = Atlas::Engine::GetClock() - time;</div><div class="line">        time = Atlas::Engine::GetClock();</div><div class="line"></div><div class="line">        mouseHandler.Update(&amp;camera, deltaTime);</div><div class="line">        keyboardHandler.Update(&amp;camera, deltaTime);</div><div class="line"></div><div class="line">        camera.UpdateView();</div><div class="line">        camera.UpdateProjection();</div><div class="line"></div><div class="line">        masterRenderer.Update();</div><div class="line"></div><div class="line">        <a class="code" href="d1/d8b/a00406.html#ad9d527958d3354f780016c8b575dbe33">Atlas::Engine::Update</a>(deltaTime);</div><div class="line"></div><div class="line">        <span class="comment">// Rotate the root node around the y-axis. This also results in a rotation</span></div><div class="line">        <span class="comment">// of the scene node that we added to the scene.</span></div><div class="line">        scene.SetMatrix(glm::rotate((<span class="keywordtype">float</span>)time / 1000.0f, vec3(0.0f, 1.0f, 0.0f)));</div><div class="line"></div><div class="line">        scene.Update(&amp;camera, deltaTime);</div><div class="line"></div><div class="line">        <span class="comment">// This does all our rendering for us.</span></div><div class="line">        masterRenderer.RenderScene(window, &amp;renderTarget, &amp;camera, &amp;scene);</div><div class="line"></div><div class="line">        <span class="comment">// We update the window to swap our rendered stuff to the surface</span></div><div class="line">        window-&gt;Update();</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">delete</span> window;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line"></div><div class="line">}</div></div><!-- fragment --> <h4>Copy constructors/assignment operators and graphic API objects</h4>
<p>There are several classes which represent an easy interface to handle graphic API objects and content on the graphics card. These classes are Shader, ShaderStage, Mesh, Textures (Texture2D, ...), Framebuffer, etc. Now you might ask what happens when you use copy constructors or assignment operators on these classes. To put it simply: Everything is being copied. When I was developing these methods I asked myself when I wanted to use a copy constructor or an assignment operator. My answer to that question was that you only wanted to use these methods when you want a copy of the object. Or the other way around: When you don't want a copy you can always use a reference. Let's have an example: </p><div class="fragment"><div class="line"><span class="comment">// One common example would be that we want to pass a mesh as a function parameter.</span></div><div class="line"><span class="comment">// This is what you shouldn&#39;t do if you don&#39;t want to create a copy of the mesh:</span></div><div class="line"><span class="keywordtype">void</span> DoSomeStuffWithAMesh(Mesh mesh) {</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Use a reference instead to make sure the object isn&#39;t being duplicated:</span></div><div class="line"><span class="keywordtype">void</span> DoSomeStuffWithAMesh(Mesh &amp;mesh) {</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Let&#39;s go a step further:</span></div><div class="line"><span class="keywordtype">void</span> AddStuffToScene(Scene* scene, Mesh mesh) {</div><div class="line">    <span class="keywordflow">for</span> (int32_t i = 0; i &lt; 100; i++)</div><div class="line">        scene-&gt;Add(<span class="keyword">new</span> StaticMeshActor(mesh));</div><div class="line">    <span class="comment">// Store the mesh somewhere to keep it in memory.</span></div><div class="line">}</div><div class="line"><span class="comment">// Is using a copy constructor</span></div><div class="line"><span class="keyword">auto</span> mesh = Mesh();</div><div class="line"><span class="comment">// The following is really bad because the scene uses the pointer to the</span></div><div class="line"><span class="comment">// meshes to sort them properly. Because we&#39;re creating a new mesh for every</span></div><div class="line"><span class="comment">// call there are now 100 meshes in the scene</span></div><div class="line"><span class="keywordflow">for</span> (int32_t i = 0; i &lt; 100; i++)</div><div class="line">    AddStuffToScene(&amp;scene, mesh);</div><div class="line"></div><div class="line"><span class="comment">// Let&#39;s try it again:</span></div><div class="line"><span class="keywordtype">void</span> AddStuffToScene(Scene* scene, Mesh&amp; mesh) {</div><div class="line">    <span class="keywordflow">for</span> (int32_t i = 0; i &lt; 100; i++)</div><div class="line">        scene-&gt;Add(<span class="keyword">new</span> StaticMeshActor(mesh));</div><div class="line">    <span class="comment">// Store the mesh somewhere to keep it in memory.</span></div><div class="line">}</div><div class="line"><span class="comment">// Even better would be Mesh mesh(args);</span></div><div class="line"><span class="keyword">auto</span>&amp; mesh = Mesh();</div><div class="line"><span class="keywordflow">for</span> (int32_t i = 0; i &lt; 100; i++)</div><div class="line">    AddStuffToScene(&amp;scene, mesh);</div></div><!-- fragment --><p> Please note that classes like the actors contain a pointer to the classes presented above. When using an assignment operator on an actor the mesh isn't copied, but the pointer to that mesh is. </p><h4>Thread safety</h4>
<p>Most classes are not designed to be used across different threads by default. These classes have to be protected by you as the user. But there are also classes which are known to be used in several threads. These classes are the EventManager, EventDelegate, Time, AudioManager, AudioStream and AssetLoader. They can all be savely accessed by multiple threads. Note that all methods which are static e.g. OpaqueRenderer::AddConfig(...) are always thread safe. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
