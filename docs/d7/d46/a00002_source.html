<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Atlas Engine: README.md Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Atlas Engine
   &#160;<span id="projectnumber">Detailed documentation</span>
   </div>
   <div id="projectbrief">A cross-platform engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d7/d46/a00002.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">README.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="../../d7/d46/a00002.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Atlas Engine</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;![Example scene](image.png)</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;## Introduction</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;This is a cross platform engine that is available on all major platforms including Linux, Windows, MacOS and Android.</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;&gt;**Note:**</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;&gt;MacOS only supports OpenGL up to version 4.1. Support is temporarily disabled until Vulkan is supported by the engine.</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;&gt;Only 64 bit compilation is supported</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;## Requirements</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;- OpenGL 4.3 or higher</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;- OpenGL ES 3.2</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;## Installation</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;Before you start compiling make sure to download the dependencies into **./dependencies**. You can either do</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;this manually or use one of the available scripts. Building the engine is really convenient: You can use your</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;source code and project across all supported platforms. The only thing that differs are the build tools. </div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;&gt;**Note:**</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;&gt;Debugging the resulting application in a debug configuration will result in poor performance. </div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;### Linux, Windows and MacOS</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;The installation is done using CMake. There are two options available: Start a new project with a predefined</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;main file which you can edit. The second option is two use the engine as a subproject in an already existing project.</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;#### New project using the engine</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;After running CMake you can find the main file at **./src/main.cpp**. Just start your project there, it already</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;contains a main function.</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;#### Excisting project using the engine</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;There exist two options:</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;- You can use the engine as a CMake subproject. Just go ahead and use **add_subdirectory** in the root</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;CMakeLists.txt of your project. Afterwards add **target_link_libraries(YOUR_TARGET ... AtlasEngine)**. You should be fine.</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;- You can compile the engine and all dependencies as a static library (note that some dependencies also have</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;dynamic libraries). Therefore use the **BUILD_LIBRARY** option when using CMake.</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;### Android</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;The installation for Android is done differently. You can compile it using Gradle either with or without AndroidStudio.</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;The Gradle project can be found in **./platform/android**. Open it before you proceed.</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;There are also two options available: Start a new project with a predefined</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;main file which you can edit. The second option is two use the engine as a subproject in an already existing project.</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;#### New project using the engine</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;You can find the main file at **./src/main.cpp**. Just start your project there, it already</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;contains a main function. </div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;#### Excisting project using the engine</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;There exist two options:</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;- You can use the engine as a Gradle subproject.</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;- You can compile the engine and all dependencies as a static library (note that some dependencies also have</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;dynamic libraries). Therefore set the project property to **BUILD_LIBRARY**.</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;## Documentation</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;If you want more information have a look into the [Documentation](https://tippesi.github.io/Atlas-Engine/index.html)</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;## General performance tips</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;- Use static/stationary objects and lights as often as possible</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;- Use textures with the same size and format for each material</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;- Set mesh data or any kind of data prior to rendering. More importantly: Don&#39;t create data while rendering.</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;- Try to avoid using OpenGL, use existing engine features instead</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;- Reduce the number of samples used for anisotropic filtering (default is the maximum possbile number of samples)</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;## Code Example</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;Here is a small introduction to the engine</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;```c</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;#include &lt;Engine.h&gt;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;#include &lt;input/Mouse.h&gt;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;#include &lt;input/Keyboard.h&gt;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;int main(int argc, char* argv[]) {</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;   // After initializing the engine we will get back a window object.</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;   // We also need to tell in which directory all the assets are, so that</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;   // we can use relative paths later on. Note that everything about the</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;   // engine is in the Atlas namespace.</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;   auto window = Atlas::Engine::Init(&quot;../data&quot;, &quot;shader&quot;, &quot;Example application&quot;,</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;           AE_WINDOWPOSITION_UNDEFINED, AE_WINDOWPOSITION_UNDEFINED, 1280, 720, AE_WINDOW_RESIZABLE);</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;   // Load an icon for the window</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;   auto icon = Atlas::Texture::Texture2D(&quot;icon.png&quot;);</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;   window-&gt;SetIcon(&amp;icon);</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;   window-&gt;Update();</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;   // Let&#39;s set up our render target. All things get drawn to the render target</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;   // before they are displayed.</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;   auto renderTarget = Atlas::RenderTarget(1920, 1080);</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;   // We also need a master renderer</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;   auto masterRenderer = Atlas::Renderer::MasterRenderer();</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;   // Now create our scene</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;   auto scene = Atlas::Scene::Scene();</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;   // We want to have a camera too</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;   auto camera = Atlas::Camera(47.0f, 2.0f, 1.0f, 400.0f, vec3(30.0f, 25.0f, 0.0f), vec2(-3.14f / 2.0f, 0.0f));</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;   // Now load the meshes we later want to use to create instances of them.</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;   // We can add these instances of meshes, called MeshActor to our scene.</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;   auto sponzaMesh = Atlas::Mesh::Mesh(&quot;sponza/sponza.dae&quot;, AE_STATIONARY_MESH);</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;   auto treeMesh = Atlas::Mesh::Mesh(&quot;tree.dae&quot;, AE_STATIONARY_MESH);</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;   auto cubeMesh = Atlas::Mesh::Mesh(&quot;cube.dae&quot;, AE_MOVABLE_MESH);</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;   // Notice that we want to move our cube later on. All meshes where we frequently want to</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;   // update the positions should be AE_MOVABLE_MESH. Let&#39;s create our MeshActors then:</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;   auto sponzaActor = Atlas::Actor::StaticMeshActor(&amp;sponzaMesh, glm::scale(vec3(0.05f)));</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;   auto treeActor = Atlas::Actor::StaticMeshActor(&amp;treeMesh, glm::scale(vec3(3.0f)));</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;   auto cubeActor = Atlas::Actor::MovableMeshActor(&amp;cubeMesh);</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;   // We create a scene node, which we can later move around.</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;   // The concept is really easy to understand: All actors of all the different types</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;   // which are added to that scene node translate, rotate and scale relative to the translation,</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;   // rotation and scale of that scene node.</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;   auto sceneNode = Atlas::Scene::SceneNode();</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;   // Notice that we add the scene node. The root node can also be translated, rotated and scaled.</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;   // We will use this later on.</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;   scene.Add(&amp;sceneNode);</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;   // Translate the scene node</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;   sceneNode.SetMatrix(glm::translate(vec3(0.0f, 1.0f, 5.0f)));</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;   // We can also add the actors to scene without adding them to a scene node.</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;   // This means that all actors added this way have an absolute translation, rotation and scale.</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;   scene.Add(&amp;sponzaActor);</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;   scene.Add(&amp;treeActor);</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;   sceneNode.Add(&amp;cubeActor);</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;   // Let&#39;s also create a global directional light. This is also stationary for this example scene.</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;   auto directionalLight = Atlas::Lighting::DirectionalLight(AE_STATIONARY_LIGHT);</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;   // Now we can change this light to our needs</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;   directionalLight.direction = vec3(0.0f, -1.0f, 0.1f);</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;   directionalLight.ambient = 0.05f;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;   directionalLight.color = vec3(253.0f, 194.0f, 109.0f) / 255.0f;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;   // Shadow mapping that is fixed to a point</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;   mat4 orthoProjection = glm::ortho(-100.0f, 100.0f, -70.0f, 120.0f, -120.0f, 120.0f);</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;   directionalLight.AddShadow(200.0f, 0.01f, 4096, vec3(0.0f), orthoProjection);</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;   directionalLight.GetShadow()-&gt;sampleCount = 1;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;   // A shadow has to be added to work</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;   directionalLight.AddVolumetric(renderTarget.width / 2, renderTarget.height / 2, 20, -0.5f);</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;   scene.Add(&amp;directionalLight);</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;   // We also want to interact with our little application. We therefore create a keyboard and mouse</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;   // handler. The handlers which are currently present in the engine are very basic but can be seen</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;   // as an example on how to write your own ones.</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;   auto mouseHandler = Atlas::Input::MouseHandler(&amp;camera, 1.5f, 0.015f);</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;   auto keyboardHandler = Atlas::Input::KeyboardHandler(&amp;camera, 7.0f, 0.3f);</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;   // We might also want to know when to exit the application. The engine has an event system build</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;   // in. We use it to catch the events from the user. In this case we want to know if the user has</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;   // closed the window (QuitEvent) or if the user pressed the escape button (KeyboardEvent).</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;   bool quit = false;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;   Atlas::Events::EventManager::QuitEventDelegate.Subscribe([&amp;quit]() {quit = true;});</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;   Atlas::Events::EventManager::KeyboardEventDelegate.Subscribe([&amp;quit](Atlas::Events::KeyboardEvent event) {</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;       if (event.keycode == AE_KEY_ESCAPE) {</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;           quit = true;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;       }</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;   });</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;   float time = 0.0f;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;   // We now have a main loop here which does all the rendering on a regular basis.</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;   // The framerate is locked as a standard but can also be unlocked via Atlas::Engine::UnlockFramerate()</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;   while (!quit) {</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;       auto deltaTime = Atlas::Engine::GetClock() - time;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;       time = Atlas::Engine::GetClock();</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;       mouseHandler.Update(&amp;camera, deltaTime);</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;       keyboardHandler.Update(&amp;camera, deltaTime);</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;       camera.UpdateView();</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;       camera.UpdateProjection();</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;       masterRenderer.Update();</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;       Atlas::Engine::Update(deltaTime);</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;       // Rotate the root node around the y-axis. This also results in a rotation</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;       // of the scene node that we added to the scene.</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;       scene.SetMatrix(glm::rotate((float)time / 1000.0f, vec3(0.0f, 1.0f, 0.0f)));</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;       scene.Update(&amp;camera, deltaTime);</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;       // This does all our rendering for us.</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;       masterRenderer.RenderScene(window, &amp;renderTarget, &amp;camera, &amp;scene);</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;       // We update the window to swap our rendered stuff to the surface</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;       window-&gt;Update();</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;   }</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;   delete window;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;   return 0;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;}</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;```</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;#### Copy constructors/assignment operators and graphic API objects</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;There are several classes which represent an easy interface to handle graphic API objects and content on the graphics card. These classes are Shader, ShaderStage, Mesh, Textures (Texture2D, ...), Framebuffer, etc. Now you might ask what happens when you use copy</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;constructors or assignment operators on these classes. To put it simply: Everything is being copied. When I was developing these methods</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;I asked myself when I wanted to use a copy constructor or an assignment operator. My answer to that question was that you only wanted to use these methods when you want a copy of the object. Or the other way around: When you don&#39;t want a copy you can always use a reference. Let&#39;s have an example:</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;```c</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;// One common example would be that we want to pass a mesh as a function parameter.</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;// This is what you shouldn&#39;t do if you don&#39;t want to create a copy of the mesh:</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;void DoSomeStuffWithAMesh(Mesh mesh) {</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;   </div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;}</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;// Use a reference instead to make sure the object isn&#39;t being duplicated:</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;void DoSomeStuffWithAMesh(Mesh &amp;mesh) {</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;}</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;// Let&#39;s go a step further:</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;void AddStuffToScene(Scene* scene, Mesh mesh) {</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;   for (int32_t i = 0; i &lt; 100; i++)</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;       scene-&gt;Add(new StaticMeshActor(mesh));</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;   // Store the mesh somewhere to keep it in memory.</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;}</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;// Is using a copy constructor</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;auto mesh = Mesh();</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;// The following is really bad because the scene uses the pointer to the</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;// meshes to sort them properly. Because we&#39;re creating a new mesh for every</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;// call there are now 100 meshes in the scene</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;for (int32_t i = 0; i &lt; 100; i++)</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;   AddStuffToScene(&amp;scene, mesh);</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;   </div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;// Let&#39;s try it again:</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;void AddStuffToScene(Scene* scene, Mesh&amp; mesh) {</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;   for (int32_t i = 0; i &lt; 100; i++)</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;       scene-&gt;Add(new StaticMeshActor(mesh));</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;   // Store the mesh somewhere to keep it in memory.</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;}</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;// Even better would be Mesh mesh(args);</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;auto&amp; mesh = Mesh();</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;for (int32_t i = 0; i &lt; 100; i++)</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;   AddStuffToScene(&amp;scene, mesh);</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;```</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;Please note that classes like the actors contain a pointer to the classes presented above. When using an assignment operator on an actor the mesh isn&#39;t copied, but the pointer to that mesh is.</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;#### Thread safety</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;Most classes are not designed to be used across different threads by default. These classes have to be protected by you as the user. But there are also classes which are known to be used in several threads. These classes are the EventManager, EventDelegate, Time, AudioManager, AudioStream and AssetLoader. They can all be savely accessed by multiple threads. Note that all methods which are static e.g. OpaqueRenderer::AddConfig(...) are always thread safe.</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d7/d46/a00002.html">README.md</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
